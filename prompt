├── .gitignore
├── .vscode
│   └── launch.json
├── README.md
├── examples
│   └── self_improve.py
├── poetry.toml
├── prompt
├── pyproject.toml
└── templated
    ├── __init__.py
    ├── __main__.py
    ├── _utils
    │   ├── chat2vanilla_lm.py
    │   └── llms.py
    ├── function.py
    └── templates
        ├── __old_template.py
        ├── base_template.py
        ├── fstring_template.py
        └── jinja_template.py
# ./.gitignore:
```
# Ignore compiled Python files and bytecode
*.pyc
__pycache__/

# Ignore virtual environments
venv/
env/
.venv/
.conda/

# Ignore local development settings
*.env
*.env.*
.envrc
.env.local
.env.*.local

# Ignore IDE and editor files
.vscode/
.idea/
*.sublime-workspace
*.sublime-project
*.pydevproject

# Ignore packaging and distribution files
*.egg-info/
dist/
build/
*.tar.gz
*.tar.bz2
*.zip
*.rar
*.gz
*.bz2
*.7z

# Ignore sensitive or confidential information
*.key
*.pem
*.p12
*.db
*.sqlite
*.sqlitedb
*.log
*.log.*
*.log-*
*.password
*.secret

# Ignore backup files
*~
*.bak
*.backup

# Ignore files generated by testing frameworks
coverage.xml
nosetests.xml
nosetests.json
.tox/
.pytest_cache/
pytest.ini

# Ignore other miscellaneous files
.DS_Store
Thumbs.db
desktop.ini

```


./.vscode: launch.json
# ./.vscode/launch.json:
```
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Doctests",
            "type": "python",
            "request": "launch",
            "module": "doctest",
            "args": [
                "templated/template.py"
            ]
        },
        {
            "name": "Python: Module",
            "type": "python",
            "request": "launch",
            "module": "templated",
            "justMyCode": true
        }
    ]
}
```


# ./README.md:
```
## Tests

 poetry run py.test --doctest-modules
```


./examples: self_improve.py
# ./examples/self_improve.py:
```
from glob import glob
from pathlib import Path
from textwrap import dedent

from templated import Function

ai = Function(
    dedent(
        """
        You are an artificial intelligence system. This is your codebase:
        
        {% for path, code in codebase %}
        Path: {{ path }}
        {{ code }}
        ---
        
        {% endfor %}
        
        Based on your current codebase, please suggest a new function that will make you more capable. Then, implement it.
        """
    ),
    verbose=True,
)

paths = Path("templated").glob("**/*.py")
paths = filter(lambda path: path.is_file(), paths)
codebase = [(path, path.read_text()) for path in paths]

response = ai(codebase=codebase)

print(response)

```


# ./poetry.toml:
```
[virtualenvs]
in-project = true

```


# ./prompt:
```

```


# ./pyproject.toml:
```
[tool.poetry]
name = "parselpy"
version = "0.1.0"
description = ""
authors = ["Jacob Valdez <jacob.valdez@limboid.ai>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.10"
langchain = "^0.0.152"
jinja2 = "^3.1.2"
openai = { version = "^0.27.5", extras = ["openai"] }
python-exports = "^1.0.0"


[tool.poetry.group.dev.dependencies]
gitignore-parser = "^0.1.3"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

```


./templated: __init__.py, __main__.py, function.py
# ./templated/__init__.py:
```
import sys
from types import ModuleType

from templated.function import Function
from templated.templates.__old_template import Template


class Templated(ModuleType):
    def __call__(self, *args, **kwargs):
        return Function(*args, **kwargs)


sys.modules[__name__].__class__ = Templated


__all__ = ["Function", "Template", "__call__"]

```


# ./templated/__main__.py:
```
import templated

```


./templated/_utils: chat2vanilla_lm.py, llms.py
# ./templated/_utils/chat2vanilla_lm.py:
```
from functools import wraps
from typing import Type

from langchain.schema import SystemMessage


def Chat2VanillaLM(ChatModel: Type):
    """
    Converts a given chat model class into a class that can be used as a language model.

    Args:
        ChatModel (Type[langchain.chat_models.base.BaseChatModel]): A class representing a chat model.

    Returns:
        Type: A new class representing a language model.

    Example:
        >>> from langchain.chat_models import ChatOpenAI
        >>> from templated._utils.chat2vanilla_lm import Chat2VanillaLM
        >>> LLMChatOpenAI = Chat2VanillaLM(ChatOpenAI)
        >>> llm = LLMChatOpenAI()
        >>> type(llm("Hello, world!")) == str
        True
    """
    old_call = ChatModel.__call__

    @wraps(ChatModel.__call__)
    def __call__(self, prompt: str, *args, **kwargs):
        return old_call(self, [SystemMessage(content=prompt)], *args, **kwargs).content

    return type(ChatModel.__name__, (ChatModel,), {"__call__": __call__})

```


# ./templated/_utils/llms.py:
```
import langchain.chat_models as chat_models
import langchain.llms as llms

from templated._utils.chat2vanilla_lm import Chat2VanillaLM

LLM_CONSTRUCTORS = {
    **{name: Chat2VanillaLM(getattr(chat_models, name)) for name in chat_models.__all__},
    **{name: getattr(llms, name) for name in llms.__all__},
}

_DEFAULT_LLM = None


def make_default_llm(llm_kwargs={}):
    """
    Creates a default language model to use in templated.

    Args:
        llm_kwargs (dict, optional): Additional arguments to pass to the language model constructor. Defaults to {}.

    Returns:
        callable: A function that takes in a string prompt and returns a response.

    Raises:
        ValueError: If an invalid language model is specified.

    Example:
        >>> lm = make_default_llm()
        >>> type(lm("Hello, world!")) == str
        True
    """
    global _DEFAULT_LLM
    if _DEFAULT_LLM is not None:
        return _DEFAULT_LLM

    if "model" in llm_kwargs and llm_kwargs["model"] in LLM_CONSTRUCTORS:
        try:
            _DEFAULT_LLM = LLM_CONSTRUCTORS[llm_kwargs["model"]](**llm_kwargs)
            return _DEFAULT_LLM
        except Exception as e:
            raise ValueError(f'Invalid LLM model: {llm_kwargs["model"]}') from e
    for model in LLM_CONSTRUCTORS:
        try:
            _DEFAULT_LLM = LLM_CONSTRUCTORS[model](**llm_kwargs)
            return _DEFAULT_LLM
        except Exception as e:
            pass
    raise ValueError(f"No valid LLM model found")

```


# ./templated/function.py:
```
from typing import Literal
from attr import NOTHING

from exports import export
import jinja2

# from templated.templates.__old_template import Template
from templated.templates.base_template import BaseTemplate as Template
from templated._utils.llms import LLM_CONSTRUCTORS, make_default_llm


@export
class Function:
    """
    Simple example:
        >>> from templated import Function
        >>> f = Function("Hello, {{name}}!")
        >>> result = f(name="world")
        >>> type(print(result)) == str
        True

    Stateful template args:
        >>> f2 = Function("{{greeting}}, {{name}}!")
        >>> f2(greeting="Hello")
        >>> f2(name="world")
        Hello, world!
        >>> f2(greeting="Goodbye")
        Goodbye, world!
        >>> f2()
        Goodbye, world!

    Custom LM:
        >>> from langchain.chat_models import ChatOpenAI
        >>> from templated._utils.chat2vanilla_lm import Chat2VanillaLM
        >>> from templated.function import Function
        >>> LLMChatOpenAI = Chat2VanillaLM(ChatOpenAI)
        >>> f = Function("Hello, {{name}}!", llm=LLMChatOpenAI)
        >>> assert f._template == "Hello, {{name}}!"
        >>> result = f(name="world")
        >>> type(print(result)) == str
        True
    """

    def __init__(
        self,
        template: str | jinja2.Template | Template,
        format: Template.Format = None,
        llm=None,
        verbose=False,
        **llm_kwargs,
    ):
        """
        Initializes a Parsel template (str | jinja2.Template | Template): The template to use for the function.
        format (Template.Format, optional): The format of the template. Inferred from the template by default.
        llm (callable, optional): The language model to use for the function. Defaults to templated._utils._DEFAULT_LLM.
        verbose (bool, optional): Whether to print verbose output. Defaults to False.
        **llm_kwargs: Additional arguments to pass to the language model constructor.
        """
        self.template = Template.create_template(template, format=format)
        self.vars = {k: NOTHING for k in self.template.vars}
        self.llm = llm or make_default_llm(llm_kwargs=llm_kwargs)
        self.verbose = verbose

    def __call__(self, **kwargs) -> str | None:
        """
        Calls the function with the specified keyword arguments.

        Args:
            **kwargs: The keyword arguments to pass to the function.

        Returns:
            str | None: If all template variables are filled, returns the response to the template. Otherwise, returns self.
        """
        self.vars.update(kwargs)
        if NOTHING in self.vars.values():
            return self
        rendered_template = self.template.render(**self.vars)
        if self.verbose:
            print(f"Rendered template: {rendered_template}")
        return self.llm(rendered_template)

```


./templated/templates: __old_template.py, base_template.py, fstring_template.py, jinja_template.py
# ./templated/templates/__old_template.py:
```
from __future__ import annotations

from enum import Enum
from functools import cache, cached_property
import re
from typing import Literal
from exports import export
import jinja2


@export
class Template:
    class Format(Enum):
        JINJA2 = "Jinja2"
        FSTRING = "f-string"

    _template_source: str
    _template: str | jinja2.Template

    def __init__(self, template: str | jinja2.Template, format: Template.Format = None):
        """
        Initializes a Template object.

        Args:
            template (str | jinja2.Template): The template to use for the object.
            format (Template.Format, optional): The format of the template. Defaults to None.

        Example:
            >>> print("This is an example")
            This is an example
            >>> from templated import Template
            >>> t = Template("Hello, {{name}}!")
            >>> print(t.render(name="world"))
            Hello, world!
        """
        if isinstance(template, Template):
            self.__dict__ = template.__dict__
            return

        self._template_source = template

        # override format if specified
        if format is not None:
            self.format = format
        # must test double braces before single braces
        elif re.search(r"{{.*?}}", template):
            self.format = Template.Format.JINJA2
        elif re.match(r"{.*?}", template):
            self.format = Template.Format.FSTRING
        # if no braces, default to fstring
        else:
            self.format = Template.Format.FSTRING
            # raise ValueError(f"Invalid template format: {self}. Must be either an fstring or a Jinja2.Template")

        match self.format:
            case Template.Format.JINJA2:
                self._template = jinja2.Template(template)
            case Template.Format.FSTRING:
                self._template = template
            case _:
                raise ValueError(f"Invalid template format: {self.format}")

    @cached_property
    def vars(self) -> list[str]:
        """
        Gets the variables used in a template string.

        Returns:
            list[str]: A list of variable names used in the template.

        Raises:
            ValueError: If the format of the template is invalid.

        Example:
            >>> from templated import Template
            >>> t = Template("Hello, {{name}}!")
            >>> print(t.vars)
            ['name']
        """
        match self.format:
            case Template.Format.JINJA2:
                var_names = re.findall(r"{{([^{}]+)}}", self._template_source)
            case Template.Format.FSTRING:
                var_names = re.findall(r"{([^{}]*)}", self._template_source)
            case _:
                raise ValueError(
                    f"Invalid template format: {self.format}. Must be either an fstring or a Jinja2.Template"
                )

        # Remove duplicates and return variable names
        return list(set(var_names))

    @cache
    def render(self, **kwargs) -> str:
        """
        Renders the template with the specified keyword arguments.

        Args:
            **kwargs: The keyword arguments to use for rendering the template.

        Returns:
            str: The rendered template string.

        Raises:
            ValueError: If the format of the template is invalid.

        Example:
            >>> from templated import Template
            >>> t = Template("Hello, {{name}}!")
            >>> print(t.render(name="world"))
            Hello, world!
        """
        match self.format:
            case Template.Format.JINJA2:
                return self._template.render(**kwargs)
            case Template.Format.FSTRING:
                return self._template.format(**kwargs)
            case _:
                raise ValueError(
                    f"Invalid template format: {self.format}. Must be either an fstring or a Jinja2.Template"
                )

```


# ./templated/templates/base_template.py:
```
from __future__ import annotations

from abc import ABC, abstractmethod, abstractproperty
from enum import Enum
from functools import cache, cached_property
import re

import jinja2


class BaseTemplate(ABC):
    class Format(Enum):
        JINJA2 = "Jinja2"
        FSTRING = "f-string"

    format = None

    _template_source: str
    _template: str

    def __init__(self, template: str):
        self._template_source = template

    @abstractmethod
    def _render(self, **kwargs) -> str:
        pass

    @property
    @abstractmethod
    def vars(self) -> list[str]:
        pass

    @classmethod
    def create_template(
        cls, template: str | jinja2.Template, format: BaseTemplate.Format = None
    ):
        """
        Creates a Template object. Determines the format of the template automatically (or manually if specified)

        Args:
            template (str | jinja2.Template): The template to use for the object.
            format (Template.Format, optional): The format of the template. Defaults to None.

        Example:
            >>> print("This is an example")
            This is an example
            >>> from templated import Template
            >>> t = Template("Hello, {{name}}!")
            >>> print(t.render(name="world"))
            Hello, world!
        """
        from templated.templates.fstring_template import FStringTemplate
        from templated.templates.jinja_template import JinjaTemplate

        # override format if specified
        if format is BaseTemplate.Format.JINJA2:
            return JinjaTemplate(template)
        elif format is BaseTemplate.Format.FSTRING:
            return FStringTemplate(template)
        # must test double braces before single braces
        elif isinstance(template, str) and re.search(r"{{.*?}}", template):
            return JinjaTemplate(template)
        elif isinstance(template, str) and re.match(r"{.*?}", template):
            return FStringTemplate(template)
        # If Jinja2 template, then its obviously a Jinja2 template
        elif isinstance(template, jinja2.Template):
            return JinjaTemplate(template)
        # if no braces, default to fstring
        elif isinstance(template, str):
            return FStringTemplate(template)
        else:
            raise ValueError(
                f"Invalid template format for {template}. Must be either an fstring or a Jinja2.Template or a Jinja2.Template string"
            )

    def render(self, **kwargs) -> str:
        return self._render(**kwargs)

```


# ./templated/templates/fstring_template.py:
```
from functools import cached_property
import re
from templated.templates.base_template import BaseTemplate


class FStringTemplate(BaseTemplate):
    format = BaseTemplate.Format.FSTRING
    _template: str

    def __init__(self, template: str):
        super().__init__(template)
        self._template = template

    @cached_property
    def vars(self) -> list[str]:
        var_names = re.findall(r"{([^{}]*)}", self._template_source)
        return list(set(var_names))

    def _render(self, **kwargs) -> str:
        return self._template.format(**kwargs)

```


# ./templated/templates/jinja_template.py:
```
from functools import cached_property
import re
import jinja2
from jinja2 import Environment, meta
from templated.templates.base_template import BaseTemplate


class JinjaTemplate(BaseTemplate):
    format = BaseTemplate.Format.JINJA2
    _template: jinja2.Template

    def __init__(self, template: str):
        super().__init__(template)
        self._template = jinja2.Template(template)

    @cached_property
    def vars(self) -> list[str]:
        env = Environment()  # You can pass any other options to the environment
        parsed_content = env.parse(self._template_source)
        variables = meta.find_undeclared_variables(parsed_content)
        return list(set(variables))

    def _render(self, **kwargs) -> str:
        return self._template.render(**kwargs)

```


